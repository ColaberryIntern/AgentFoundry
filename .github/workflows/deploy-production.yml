name: Deploy to Production

on:
  workflow_dispatch:
  push:
    branches: [main]

concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  SERVER_HOST: 95.216.199.47
  SERVER_USER: root
  APP_DIR: /opt/agent-foundry
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/agent-foundry
  K8S_NAMESPACE: agent-foundry-production

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        service:
          - api-gateway
          - user-service
          - compliance-monitor-service
          - reporting-service
          - notification-service
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
      - name: Install and test
        working-directory: services/${{ matrix.service }}
        run: npm ci && npm test

  test-client:
    name: Test Client
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
      - name: Install and type-check
        working-directory: client
        run: npm ci && npx tsc --noEmit

  deploy:
    name: Deploy to Hetzner
    runs-on: ubuntu-latest
    needs: [test, test-client]
    environment:
      name: production
      url: http://95.216.199.47
    steps:
      - uses: actions/checkout@v4

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ secrets.HETZNER_SSH_KEY }}
          script_stop: true
          command_timeout: 10m
          script: |
            set -e

            # Clone or pull latest code
            if [ -d "${{ env.APP_DIR }}" ]; then
              cd ${{ env.APP_DIR }}
              git fetch origin main
              git reset --hard origin/main
            else
              git clone https://github.com/ColaberryIntern/AgentFoundry.git ${{ env.APP_DIR }}
              cd ${{ env.APP_DIR }}
            fi

            # Create .env from secrets if not exists
            if [ ! -f .env ]; then
              cp .env.example .env
              echo "WARNING: Using default .env — update with production secrets"
            fi

            # Build and deploy with Docker Compose
            docker compose down --remove-orphans || true
            docker compose build --no-cache
            docker compose up -d

            # Wait for services to be healthy
            echo "Waiting for services to start..."
            sleep 15

            # Health checks
            echo "=== Health Checks ==="
            for port in 3000 3001 3002 3003 3005; do
              status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${port}/health || echo "000")
              echo "Port ${port}: HTTP ${status}"
              if [ "$status" != "200" ]; then
                echo "WARNING: Service on port ${port} not healthy"
              fi
            done

            # Show running containers
            echo ""
            echo "=== Running Containers ==="
            docker compose ps

            echo ""
            echo "Deployment complete!"

  # ── Blue-Green K8s Deployment (optional, trigger manually) ────────
  # This job is for future K8s-based production deployments.
  # Activate by setting use_k8s: true in workflow_dispatch inputs.
  deploy-k8s-blue-green:
    name: Blue-Green K8s Deploy
    runs-on: ubuntu-latest
    needs: [test, test-client]
    if: github.event_name == 'workflow_dispatch'
    environment:
      name: production-k8s
      url: https://agent-foundry.example.com
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push images
        run: |
          SERVICES="api-gateway user-service compliance-monitor-service reporting-service ai-recommendation-service notification-service"
          for svc in $SERVICES; do
            docker buildx build \
              --file docker/Dockerfile.service \
              --build-arg SERVICE_DIR=services/${svc} \
              --push \
              --tag ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${svc}:${{ github.sha }} \
              --tag ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${svc}:production \
              --cache-from type=gha \
              --cache-to type=gha,mode=max \
              .
          done
          # Build client separately
          docker buildx build \
            --file docker/Dockerfile.client \
            --push \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/client:${{ github.sha }} \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/client:production \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            .

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.HETZNER_KUBECONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Determine deployment color
        id: color
        run: |
          CURRENT=$(kubectl get svc api-gateway-bg -n ${{ env.K8S_NAMESPACE }} \
            -o jsonpath='{.spec.selector.deployment-color}' 2>/dev/null || echo "blue")
          if [ "$CURRENT" = "blue" ]; then
            echo "new_color=green" >> $GITHUB_OUTPUT
            echo "old_color=blue" >> $GITHUB_OUTPUT
          else
            echo "new_color=blue" >> $GITHUB_OUTPUT
            echo "old_color=green" >> $GITHUB_OUTPUT
          fi
          echo "Current: ${CURRENT}, deploying as: $([ "$CURRENT" = "blue" ] && echo green || echo blue)"

      - name: Label and deploy green workloads
        run: |
          NEW_COLOR=${{ steps.color.outputs.new_color }}
          SERVICES="api-gateway user-service compliance-monitor-service reporting-service ai-recommendation-service notification-service client"

          # Update image tags in manifests
          cd k8s/base
          for svc in $SERVICES; do
            sed -i "s|image:.*${svc}.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${svc}:${{ github.sha }}|g" ${svc}.yml
          done
          cd ../..

          # Apply with kustomize using production overlay
          kubectl apply -k k8s/production/ -n ${{ env.K8S_NAMESPACE }}

          # Label new pods with deployment color
          for svc in $SERVICES; do
            kubectl patch deployment ${svc} -n ${{ env.K8S_NAMESPACE }} \
              --type='json' \
              -p="[{\"op\":\"add\",\"path\":\"/spec/template/metadata/labels/deployment-color\",\"value\":\"${NEW_COLOR}\"}]" \
              || true
          done

      - name: Wait for rollout
        run: |
          SERVICES="api-gateway user-service compliance-monitor-service reporting-service ai-recommendation-service notification-service client"
          for svc in $SERVICES; do
            echo "Waiting for ${svc} rollout..."
            kubectl rollout status deployment/${svc} -n ${{ env.K8S_NAMESPACE }} --timeout=300s
          done

      - name: Verify deployment health
        run: |
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -o wide
          echo ""

          # Check all pods are ready
          NOT_READY=$(kubectl get pods -n ${{ env.K8S_NAMESPACE }} \
            --field-selector=status.phase!=Running -o name 2>/dev/null | wc -l)
          if [ "$NOT_READY" -gt 0 ]; then
            echo "WARNING: ${NOT_READY} pod(s) not in Running state"
            kubectl get pods -n ${{ env.K8S_NAMESPACE }} --field-selector=status.phase!=Running
          fi

          echo ""
          echo "=== Service Status ==="
          kubectl get svc -n ${{ env.K8S_NAMESPACE }}
          echo ""
          echo "=== Ingress Status ==="
          kubectl get ingress -n ${{ env.K8S_NAMESPACE }}

      - name: Switch blue-green services
        run: |
          NEW_COLOR=${{ steps.color.outputs.new_color }}
          BG_SERVICES="api-gateway-bg user-service-bg compliance-monitor-service-bg client-bg"
          for svc in $BG_SERVICES; do
            kubectl patch svc ${svc} -n ${{ env.K8S_NAMESPACE }} \
              -p "{\"spec\":{\"selector\":{\"deployment-color\":\"${NEW_COLOR}\"}}}" \
              2>/dev/null || echo "Service ${svc} not found (blue-green not active for this service)"
          done
          echo "Traffic switched to ${NEW_COLOR}"
