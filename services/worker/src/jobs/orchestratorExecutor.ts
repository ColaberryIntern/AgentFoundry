import logger from '../utils/logger';
import { queryRows, execSql } from '../utils/db';

// ---------------------------------------------------------------------------
// Executor â€” picks up simulation_passed actions and executes them
// ---------------------------------------------------------------------------

async function executeCreateVariant(
  params: Record<string, unknown>,
): Promise<Record<string, unknown>> {
  const industryCode = params.industryCode as string;

  // Find a suitable skeleton (default to compliance_monitor)
  const skeletons = await queryRows(
    "SELECT id, name, specialization_type FROM agent_skeletons WHERE specialization_type = 'compliance_monitor' LIMIT 1",
  );

  if (skeletons.length === 0) {
    throw new Error('No compliance_monitor skeleton found');
  }

  const skeleton = skeletons[0] as { id: string; name: string; specialization_type: string };
  const industry = await queryRows('SELECT code, title FROM naics_industries WHERE code = $1', [
    industryCode,
  ]);

  if (industry.length === 0) throw new Error(`Industry ${industryCode} not found`);

  const ind = industry[0] as { code: string; title: string };
  const variantId = crypto.randomUUID();
  const variantName = `${ind.title} Compliance Monitor`;

  await execSql(
    `
    INSERT INTO agent_variants
      (id, skeleton_id, industry_code, name, configuration, certification_status, certification_score, version, "createdAt", "updatedAt")
    VALUES ($1, $2, $3, $4, $5, 'uncertified', 0, 1, NOW(), NOW())
  `,
    [
      variantId,
      skeleton.id,
      industryCode,
      variantName,
      JSON.stringify({ checkInterval: '15m', autoGenerated: true }),
    ],
  );

  // Create a certification record (180-day validity)
  await execSql(
    `
    INSERT INTO certification_records
      (id, agent_variant_id, certification_type, compliance_framework, best_practice_score, audit_passed, findings, expiry_date, version, "createdAt", "updatedAt")
    VALUES ($1, $2, 'regulatory_compliance', 'Auto-Generated', $3, false, '[]', $4, 1, NOW(), NOW())
  `,
    [
      crypto.randomUUID(),
      variantId,
      75 + Math.random() * 20,
      new Date(Date.now() + 180 * 86400 * 1000).toISOString(),
    ],
  );

  // Log to audit trail
  await execSql(
    `
    INSERT INTO registry_audit_log (id, actor, action, entity_type, entity_id, changes, reason, "createdAt")
    VALUES ($1, 'orchestrator', 'create', 'agent_variant', $2, $3, 'Auto-generated by Executive Orchestrator', NOW())
  `,
    [
      crypto.randomUUID(),
      variantId,
      JSON.stringify({ name: variantName, industryCode, skeletonId: skeleton.id }),
    ],
  );

  return { variantId, variantName, industryCode, skeletonId: skeleton.id };
}

async function executeRecertifyAgent(
  params: Record<string, unknown>,
): Promise<Record<string, unknown>> {
  const certId = params.certId as string | undefined;
  const variantId = params.variantId as string | undefined;

  if (certId) {
    const newExpiry = new Date(Date.now() + 180 * 86400 * 1000);
    const newScore = 75 + Math.random() * 20;

    await execSql(
      `
      UPDATE certification_records
      SET expiry_date = $1, best_practice_score = $2, audit_passed = true, last_reviewed = NOW(), "updatedAt" = NOW()
      WHERE id = $3
    `,
      [newExpiry.toISOString(), newScore, certId],
    );

    if (variantId) {
      await execSql(
        `
        UPDATE agent_variants SET certification_status = 'certified', certification_score = $1, "updatedAt" = NOW()
        WHERE id = $2
      `,
        [newScore / 100, variantId],
      );
    }

    await execSql(
      `
      INSERT INTO registry_audit_log (id, actor, action, entity_type, entity_id, changes, reason, "createdAt")
      VALUES ($1, 'orchestrator', 'update', 'certification_record', $2, $3, 'Recertification by Executive Orchestrator', NOW())
    `,
      [
        crypto.randomUUID(),
        certId,
        JSON.stringify({ newExpiry: newExpiry.toISOString(), newScore }),
      ],
    );

    return { certId, newExpiry: newExpiry.toISOString(), newScore };
  }

  return { status: 'no_cert_id' };
}

async function executePauseDeployment(
  targetEntityId: string | null,
): Promise<Record<string, unknown>> {
  if (!targetEntityId) throw new Error('No deployment ID provided');

  await execSql(
    `
    UPDATE deployment_instances SET active_status = false, "updatedAt" = NOW() WHERE id = $1
  `,
    [targetEntityId],
  );

  await execSql(
    `
    INSERT INTO registry_audit_log (id, actor, action, entity_type, entity_id, changes, reason, "createdAt")
    VALUES ($1, 'orchestrator', 'update', 'deployment_instance', $2, '{"activeStatus": false}', 'Paused by Executive Orchestrator due to drift', NOW())
  `,
    [crypto.randomUUID(), targetEntityId],
  );

  return { deploymentId: targetEntityId, paused: true };
}

async function executeAdjustThreshold(
  targetEntityId: string | null,
  params: Record<string, unknown>,
): Promise<Record<string, unknown>> {
  if (!targetEntityId) throw new Error('No target entity ID');

  // For deployment instances, just log the adjustment (config is variant-level)
  const variantId = params.variantId as string | undefined;
  if (variantId) {
    await execSql(
      `
      INSERT INTO registry_audit_log (id, actor, action, entity_type, entity_id, changes, reason, "createdAt")
      VALUES ($1, 'orchestrator', 'update', 'agent_variant', $2, $3, 'Threshold adjusted by Executive Orchestrator', NOW())
    `,
      [crypto.randomUUID(), variantId, JSON.stringify({ adjustedFor: targetEntityId, params })],
    );
  }

  return { adjusted: true, targetEntityId };
}

async function executeAddOntologyRelation(
  params: Record<string, unknown>,
): Promise<Record<string, unknown>> {
  const relId = crypto.randomUUID();
  const subjectType = 'agent_skeleton';
  const subjectId = (params.skeletonId as string) || (params.targetEntityId as string);
  const relType = (params.relationshipType as string) || 'COMPLIES_WITH';

  // Find a regulation to link to
  const regs = await queryRows(`
    SELECT id, name FROM taxonomy_nodes WHERE node_type = 'regulation' LIMIT 1
  `);

  if (regs.length === 0) {
    return { status: 'no_regulations_found' };
  }

  const reg = regs[0] as { id: string; name: string };

  await execSql(
    `
    INSERT INTO ontology_relationships
      (id, subject_type, subject_id, relationship_type, object_type, object_id, weight, version, "createdAt", "updatedAt")
    VALUES ($1, $2, $3, $4, 'regulation', $5, 1.0, 1, NOW(), NOW())
    ON CONFLICT DO NOTHING
  `,
    [relId, subjectType, subjectId, relType, reg.id],
  );

  return { relationshipId: relId, subjectId, objectId: reg.id, relType };
}

// ---------------------------------------------------------------------------
// Main Executor
// ---------------------------------------------------------------------------
export async function runOrchestratorExecutor(): Promise<void> {
  // Find actions ready for execution
  const actions = await queryRows(`
    SELECT id, action_type, target_entity_type, target_entity_id, parameters, intent_id
    FROM orchestrator_actions
    WHERE status = 'simulation_passed'
    ORDER BY sequence_order ASC
    LIMIT 3
  `);

  if (actions.length === 0) return;

  for (const row of actions as Array<{
    id: string;
    action_type: string;
    target_entity_type: string | null;
    target_entity_id: string | null;
    parameters: Record<string, unknown>;
    intent_id: string;
  }>) {
    try {
      // Mark as executing
      await execSql(
        'UPDATE orchestrator_actions SET status = $1, "updatedAt" = NOW() WHERE id = $2',
        ['executing', row.id],
      );

      // Update parent intent
      await execSql(
        'UPDATE orchestrator_intents SET status = $1, "updatedAt" = NOW() WHERE id = $2',
        ['executing', row.intent_id],
      );

      const params =
        typeof row.parameters === 'string' ? JSON.parse(row.parameters) : row.parameters;

      let result: Record<string, unknown>;

      switch (row.action_type) {
        case 'create_variant':
          result = await executeCreateVariant(params);
          break;
        case 'recertify_agent':
          result = await executeRecertifyAgent(params);
          break;
        case 'pause_deployment':
          result = await executePauseDeployment(row.target_entity_id);
          break;
        case 'adjust_threshold':
          result = await executeAdjustThreshold(row.target_entity_id, params);
          break;
        case 'add_ontology_relation':
          result = await executeAddOntologyRelation({
            ...params,
            targetEntityId: row.target_entity_id,
          });
          break;
        default:
          result = { status: 'unsupported_action_type', actionType: row.action_type };
      }

      // Mark action completed
      await execSql(
        `
        UPDATE orchestrator_actions
        SET status = 'completed', execution_result = $1, "updatedAt" = NOW()
        WHERE id = $2
      `,
        [JSON.stringify(result), row.id],
      );

      // Check if all actions for this intent are done
      const remaining = await queryRows(
        `
        SELECT COUNT(*) as cnt FROM orchestrator_actions
        WHERE intent_id = $1 AND status NOT IN ('completed', 'failed', 'rolled_back')
      `,
        [row.intent_id],
      );

      if ((remaining[0] as { cnt: number }).cnt === 0) {
        await execSql(
          `
          UPDATE orchestrator_intents
          SET status = 'completed', resolved_at = NOW(), resolved_by = 'orchestrator', "updatedAt" = NOW()
          WHERE id = $1
        `,
          [row.intent_id],
        );
      }

      logger.info(`Executed action: ${row.action_type}`, {
        job: 'orchestratorExecutor',
        actionId: row.id,
        result,
      });
    } catch (err) {
      await execSql(
        `
        UPDATE orchestrator_actions
        SET status = 'failed', error_message = $1, "updatedAt" = NOW()
        WHERE id = $2
      `,
        [(err as Error).message, row.id],
      );

      logger.error(`Execution failed for action ${row.id}`, {
        job: 'orchestratorExecutor',
        error: (err as Error).message,
      });
    }
  }
}
